# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-01-30T17:07:56.190
# original file: /home/fabio/pCloudDrive/projects/GTT/matomqtt/protobuf/posupdate.proto (proto3 syntax)

module posupdate_pb

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export PositionUpdate

struct PositionUpdate
    line::String
    veh::String
    lat::Float64
    lon::Float64
    heading::Int32
    speed::Int32
    tripId::String
    direction::Int32
    nextStop::String
    full::Int32
    timerec::Int64
end
PB.default_values(::Type{PositionUpdate}) = (;line = "", veh = "", lat = zero(Float64), lon = zero(Float64), heading = zero(Int32), speed = zero(Int32), tripId = "", direction = zero(Int32), nextStop = "", full = zero(Int32), timerec = zero(Int64))
PB.field_numbers(::Type{PositionUpdate}) = (;line = 1, veh = 2, lat = 3, lon = 4, heading = 5, speed = 6, tripId = 7, direction = 8, nextStop = 9, full = 10, timerec = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PositionUpdate})
    line = ""
    veh = ""
    lat = zero(Float64)
    lon = zero(Float64)
    heading = zero(Int32)
    speed = zero(Int32)
    tripId = ""
    direction = zero(Int32)
    nextStop = ""
    full = zero(Int32)
    timerec = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            line = PB.decode(d, String)
        elseif field_number == 2
            veh = PB.decode(d, String)
        elseif field_number == 3
            lat = PB.decode(d, Float64)
        elseif field_number == 4
            lon = PB.decode(d, Float64)
        elseif field_number == 5
            heading = PB.decode(d, Int32)
        elseif field_number == 6
            speed = PB.decode(d, Int32)
        elseif field_number == 7
            tripId = PB.decode(d, String)
        elseif field_number == 8
            direction = PB.decode(d, Int32)
        elseif field_number == 9
            nextStop = PB.decode(d, String)
        elseif field_number == 10
            full = PB.decode(d, Int32)
        elseif field_number == 11
            timerec = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return PositionUpdate(line, veh, lat, lon, heading, speed, tripId, direction, nextStop, full, timerec)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PositionUpdate)
    initpos = position(e.io)
    !isempty(x.line) && PB.encode(e, 1, x.line)
    !isempty(x.veh) && PB.encode(e, 2, x.veh)
    x.lat != zero(Float64) && PB.encode(e, 3, x.lat)
    x.lon != zero(Float64) && PB.encode(e, 4, x.lon)
    x.heading != zero(Int32) && PB.encode(e, 5, x.heading)
    x.speed != zero(Int32) && PB.encode(e, 6, x.speed)
    !isempty(x.tripId) && PB.encode(e, 7, x.tripId)
    x.direction != zero(Int32) && PB.encode(e, 8, x.direction)
    !isempty(x.nextStop) && PB.encode(e, 9, x.nextStop)
    x.full != zero(Int32) && PB.encode(e, 10, x.full)
    x.timerec != zero(Int64) && PB.encode(e, 11, x.timerec)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PositionUpdate)
    encoded_size = 0
    !isempty(x.line) && (encoded_size += PB._encoded_size(x.line, 1))
    !isempty(x.veh) && (encoded_size += PB._encoded_size(x.veh, 2))
    x.lat != zero(Float64) && (encoded_size += PB._encoded_size(x.lat, 3))
    x.lon != zero(Float64) && (encoded_size += PB._encoded_size(x.lon, 4))
    x.heading != zero(Int32) && (encoded_size += PB._encoded_size(x.heading, 5))
    x.speed != zero(Int32) && (encoded_size += PB._encoded_size(x.speed, 6))
    !isempty(x.tripId) && (encoded_size += PB._encoded_size(x.tripId, 7))
    x.direction != zero(Int32) && (encoded_size += PB._encoded_size(x.direction, 8))
    !isempty(x.nextStop) && (encoded_size += PB._encoded_size(x.nextStop, 9))
    x.full != zero(Int32) && (encoded_size += PB._encoded_size(x.full, 10))
    x.timerec != zero(Int64) && (encoded_size += PB._encoded_size(x.timerec, 11))
    return encoded_size
end
end # module
